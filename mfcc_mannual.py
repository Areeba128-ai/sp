# -*- coding: utf-8 -*-
"""MFCC_mannual.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16y4BjLZ2whCJXJXn_zhK1x4dYii-X1y_
"""

import os
import librosa
import librosa.display
import soundfile as sf
import matplotlib.pyplot as plt
import IPython.display as ipd
import numpy as np
from sklearn.metrics import mean_squared_error
from scipy.fftpack import dct

data_dir = "/kaggle/input/librispeech/dev-clean/"


flac_files = []
for root, _, files in os.walk(data_dir):
    for file in files:
        if file.endswith(".flac"):
            flac_files.append(os.path.join(root, file))

print("Total .flac files found:", len(flac_files))
print("Example file path:", flac_files[0])


# Load one sample
sample_file = flac_files[0]
audio, sr = librosa.load(sample_file, sr=None)
print(f"Sample rate: {sr}, Duration: {len(audio)/sr:.2f} seconds")

# Listen to the audio
ipd.Audio(sample_file)

data_dir = "/kaggle/input/librispeech/dev-clean/"

# Find first .flac file
flac_files = []
for root, _, files in os.walk(data_dir):
    for file in files:
        if file.endswith(".flac"):
            flac_files.append(os.path.join(root, file))

sample_file = flac_files[0]
print("Using file:", sample_file)

# Load audio
signal, sr = librosa.load(sample_file, sr=None)
print("Sample rate:", sr, "| Duration:", len(signal)/sr, "seconds")


# ---------- Step 1: Pre-Emphasis ----------
def pre_emphasis(signal, coeff=0.97):
    return np.append(signal[0], signal[1:] - coeff * signal[:-1])

# ---------- Step 2: Framing ----------
def framing(signal, sr, frame_size=0.025, frame_stride=0.010):
    frame_length = int(frame_size * sr)
    frame_step = int(frame_stride * sr)
    num_frames = int(np.ceil(float(np.abs(len(signal) - frame_length)) / frame_step))

    pad_signal_length = num_frames * frame_step + frame_length
    z = np.zeros((pad_signal_length - len(signal)))
    pad_signal = np.append(signal, z)

    indices = np.tile(np.arange(0, frame_length), (num_frames, 1)) + \
              np.tile(np.arange(0, num_frames * frame_step, frame_step), (frame_length, 1)).T
    frames = pad_signal[indices.astype(np.int32, copy=False)]
    return frames

# ---------- Step 3: Windowing (Hamming) ----------
def hamming_window(N):
    return 0.54 - 0.46 * np.cos(2 * np.pi * np.arange(N) / (N - 1))

def apply_window(frames):
    window = hamming_window(frames.shape[1])
    return frames * window

# ---------- Step 4: FFT and Power Spectrum ----------
def power_spectrum(frames, NFFT=512):
    mag_frames = np.absolute(np.fft.rfft(frames, NFFT))
    pow_frames = ((1.0 / NFFT) * (mag_frames ** 2))
    return pow_frames

# ---------- Step 5: Mel Filterbank ----------
def hz_to_mel(hz): return 2595 * np.log10(1 + hz / 700)
def mel_to_hz(mel): return 700 * (10**(mel / 2595) - 1)

def mel_filterbank(pow_frames, sr, NFFT=512, nfilt=26):
    low_mel = hz_to_mel(0)
    high_mel = hz_to_mel(sr / 2)
    mel_points = np.linspace(low_mel, high_mel, nfilt + 2)
    hz_points = mel_to_hz(mel_points)
    bin_points = np.floor((NFFT + 1) * hz_points / sr).astype(int)

    fbank = np.zeros((nfilt, int(NFFT / 2 + 1)))
    for m in range(1, nfilt + 1):
        f_m_minus = bin_points[m - 1]
        f_m = bin_points[m]
        f_m_plus = bin_points[m + 1]

        for k in range(f_m_minus, f_m):
            fbank[m - 1, k] = (k - f_m_minus) / (f_m - f_m_minus)
        for k in range(f_m, f_m_plus):
            fbank[m - 1, k] = (f_m_plus - k) / (f_m_plus - f_m)

    filter_banks = np.dot(pow_frames, fbank.T)
    filter_banks = np.where(filter_banks == 0, np.finfo(float).eps, filter_banks)
    return np.log(filter_banks)

# ---------- Step 6: DCT to Get MFCC ----------
def compute_mfcc(log_energies, num_ceps=13):
    mfcc = np.array([dct(f, type=2, norm='ortho')[:num_ceps] for f in log_energies])
    mfcc -= (np.mean(mfcc, axis=0) + 1e-8)
    return mfcc

# ---------- Step 7: Combine Everything ----------
def mfcc_from_scratch(signal, sr):
    emphasized = pre_emphasis(signal)
    frames = framing(emphasized, sr)
    windowed_frames = apply_window(frames)
    pow_frames = power_spectrum(windowed_frames)
    log_energies = mel_filterbank(pow_frames, sr)
    mfcc = compute_mfcc(log_energies)
    return mfcc

# Mannual MFCC
mfcc_manual = mfcc_from_scratch(signal, sr)

# Librosa MFCC (reference)
mfcc_librosa = librosa.feature.mfcc(y=signal, sr=sr, n_mfcc=13)

print("Manual MFCC shape:", mfcc_manual.shape)
print("Librosa MFCC shape:", mfcc_librosa.T.shape)


# Align shapes
min_frames = min(mfcc_manual.shape[0], mfcc_librosa.shape[1])
mfcc_manual = mfcc_manual[:min_frames]
mfcc_librosa = mfcc_librosa[:, :min_frames].T

# Mean Squared Error (MSE)
mse = mean_squared_error(mfcc_manual.flatten(), mfcc_librosa.flatten())

# Signal-to-Noise Ratio (SNR)
signal_power = np.mean(mfcc_librosa ** 2)
noise_power = np.mean((mfcc_librosa - mfcc_manual) ** 2)
snr = 10 * np.log10(signal_power / noise_power)

print(f"MSE: {mse:.6f}")
print(f"SNR: {snr:.2f} dB")



plt.figure(figsize=(14, 5))
plt.subplot(1, 2, 1)
librosa.display.specshow(mfcc_manual.T, sr=sr, x_axis='time')
plt.title("MFCC (From Scratch)")
plt.colorbar()

plt.subplot(1, 2, 2)
librosa.display.specshow(mfcc_librosa, sr=sr, x_axis='time')
plt.title("MFCC (Librosa)")
plt.colorbar()
plt.show()

mse_list, snr_list = [], []

for file in flac_files[:10]:  # limit to 10 files
    signal, sr = librosa.load(file, sr=None)
    mfcc_manual = mfcc_from_scratch(signal, sr)
    mfcc_librosa = librosa.feature.mfcc(y=signal, sr=sr, n_mfcc=13)
    min_frames = min(mfcc_manual.shape[0], mfcc_librosa.shape[1])
    mfcc_manual = mfcc_manual[:min_frames]
    mfcc_librosa = mfcc_librosa[:, :min_frames].T
    mse = mean_squared_error(mfcc_manual.flatten(), mfcc_librosa.flatten())
    signal_power = np.mean(mfcc_librosa ** 2)
    noise_power = np.mean((mfcc_librosa - mfcc_manual) ** 2)
    snr = 10 * np.log10(signal_power / noise_power)
    mse_list.append(mse)
    snr_list.append(snr)

print(f"Average MSE across 10 files: {np.mean(mse_list):.6f}")
print(f"Average SNR across 10 files: {np.mean(snr_list):.2f} dB")

